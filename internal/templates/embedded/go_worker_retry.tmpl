package retry

// =============================================================================
// RETRY WITH BACKOFF
// =============================================================================
// Resilient retry logic with exponential backoff
// =============================================================================

import (
	"context"   // Context for cancellation
	"fmt"       // Formatting
	"math"      // Math functions
	"math/rand" // Random for jitter
	"time"      // Timing
)

// =============================================================================
// CONFIGURATION
// =============================================================================

// Config holds retry configuration
type Config struct {
	MaxRetries  int           // Maximum number of retries (0 = no retries)
	InitialWait time.Duration // Initial wait time between retries
	MaxWait     time.Duration // Maximum wait time between retries
	Multiplier  float64       // Backoff multiplier (e.g., 2.0 for exponential)
	Jitter      float64       // Random jitter factor (0.0 to 1.0)
}

// DefaultConfig returns sensible retry defaults
// Returns:
//   - Config: Default configuration
func DefaultConfig() Config {
	return Config{
		MaxRetries:  3,                     // 3 retries
		InitialWait: 100 * time.Millisecond, // Start at 100ms
		MaxWait:     10 * time.Second,      // Max 10s between retries
		Multiplier:  2.0,                   // Double each time
		Jitter:      0.1,                   // 10% jitter
	}
}

// =============================================================================
// RETRY FUNCTION
// =============================================================================

// Do executes a function with retry and backoff
// Parameters:
//   - ctx: Context for cancellation
//   - cfg: Retry configuration
//   - fn: Function to execute, returns error if should retry
// Returns:
//   - error: Final error if all retries exhausted
func Do(ctx context.Context, cfg Config, fn func() error) error {
	var lastErr error

	for attempt := 0; attempt <= cfg.MaxRetries; attempt++ {
		// Check context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		// Execute function
		lastErr = fn()
		if lastErr == nil {
			return nil // Success
		}

		// Don't wait after last attempt
		if attempt == cfg.MaxRetries {
			break
		}

		// Calculate wait time with backoff
		wait := cfg.calculateWait(attempt)

		// Wait before next retry
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(wait):
		}
	}

	return fmt.Errorf("after %d retries: %w", cfg.MaxRetries, lastErr)
}

// calculateWait calculates wait time for a given attempt
// Parameters:
//   - attempt: Current attempt number (0-indexed)
// Returns:
//   - time.Duration: Wait time with jitter
func (c Config) calculateWait(attempt int) time.Duration {
	// Exponential backoff
	backoff := float64(c.InitialWait) * math.Pow(c.Multiplier, float64(attempt))

	// Cap at max wait
	if backoff > float64(c.MaxWait) {
		backoff = float64(c.MaxWait)
	}

	// Add jitter
	if c.Jitter > 0 {
		jitter := backoff * c.Jitter * (rand.Float64()*2 - 1) // -jitter to +jitter
		backoff += jitter
	}

	return time.Duration(backoff)
}

// =============================================================================
// PERMANENT ERROR
// =============================================================================

// PermanentError wraps an error that should not be retried
type PermanentError struct {
	Err error // Underlying error
}

// Error implements error interface
func (e *PermanentError) Error() string {
	return e.Err.Error()
}

// Unwrap returns underlying error
func (e *PermanentError) Unwrap() error {
	return e.Err
}

// Permanent wraps an error to indicate it should not be retried
// Parameters:
//   - err: Error to wrap
// Returns:
//   - error: Wrapped permanent error
func Permanent(err error) error {
	return &PermanentError{Err: err}
}

// IsPermanent checks if error is permanent (should not retry)
// Parameters:
//   - err: Error to check
// Returns:
//   - bool: True if permanent error
func IsPermanent(err error) bool {
	var permanent *PermanentError
	return errors.As(err, &permanent)
}

// DoWithPermanent executes with retry, stopping on permanent errors
// Parameters:
//   - ctx: Context for cancellation
//   - cfg: Retry configuration
//   - fn: Function to execute
// Returns:
//   - error: Final error
func DoWithPermanent(ctx context.Context, cfg Config, fn func() error) error {
	return Do(ctx, cfg, func() error {
		err := fn()
		if err != nil && IsPermanent(err) {
			// Return nil to stop retrying, but we need to propagate error
			// This is a simplified approach - in production, use different pattern
			return nil
		}
		return err
	})
}
