package main

import (
	"sync"
	"testing"
)

func TestCounterConcurrent(t *testing.T) {
	c := &Counter{}
	var wg sync.WaitGroup
	
	// 100 goroutines each incrementing 100 times
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 100; j++ {
				c.Increment()
			}
		}()
	}
	
	wg.Wait()
	
	if c.Value() != 10000 {
		t.Errorf("Counter = %d, want 10000", c.Value())
	}
}

func TestCacheConcurrent(t *testing.T) {
	var wg sync.WaitGroup
	
	// Concurrent writes
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func(n int) {
			defer wg.Done()
			key := string(rune('a' + n%26))
			SetCache(key, "value")
			GetFromCache(key)
		}(i)
	}
	
	wg.Wait()
	// If we get here without panic, the test passes
}

func TestLoggerConcurrent(t *testing.T) {
	l := &Logger{}
	var wg sync.WaitGroup
	
	// 100 goroutines each logging 10 times
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 10; j++ {
				l.Log("message")
			}
		}()
	}
	
	wg.Wait()
	
	if len(l.GetLogs()) != 1000 {
		t.Errorf("Logger has %d logs, want 1000", len(l.GetLogs()))
	}
}
