package main

// =============================================================================
// DISTRIBUTED TRACING - Request flow tracking
// =============================================================================
// This file demonstrates distributed tracing patterns using context
// propagation, trace IDs, and span tracking for debugging distributed systems.
// =============================================================================

import (
	"context"      // Context for trace propagation
	"crypto/rand"  // Random ID generation
	"encoding/hex" // Hex encoding for IDs
	"fmt"          // Formatted I/O
	"log/slog"     // Structured logging
	"os"           // Standard output
	"sync"         // Mutex for span safety
	"time"         // Duration tracking
)

// =============================================================================
// TRACE ID CONTEXT KEYS
// =============================================================================

// contextKey is a custom type for context keys to avoid collisions
type contextKey string // Custom key type

const (
	traceIDKey  contextKey = "traceID"  // Key for trace ID in context
	spanIDKey   contextKey = "spanID"   // Key for span ID in context
	parentIDKey contextKey = "parentID" // Key for parent span ID
)

// =============================================================================
// ID GENERATION FUNCTIONS
// =============================================================================

// generateID creates a random hex ID of specified byte length
// Parameters:
//   - byteLen: Number of random bytes (ID will be 2x this in hex chars)
// Returns:
//   - string: Hex-encoded random ID
func generateID(byteLen int) string {
	b := make([]byte, byteLen) // Allocate byte buffer
	rand.Read(b)               // Fill with random bytes
	return hex.EncodeToString(b) // Encode as hex string
}

// NewTraceID generates a new 16-byte trace ID
// Returns:
//   - string: 32-character hex trace ID
func NewTraceID() string {
	return generateID(16) // 16 bytes = 32 hex chars
}

// NewSpanID generates a new 8-byte span ID
// Returns:
//   - string: 16-character hex span ID
func NewSpanID() string {
	return generateID(8) // 8 bytes = 16 hex chars
}

// =============================================================================
// SPAN STRUCTURE
// =============================================================================

// Span represents a unit of work in a trace
type Span struct {
	TraceID   string        // Root trace identifier
	SpanID    string        // This span's identifier
	ParentID  string        // Parent span identifier (empty for root)
	Name      string        // Span operation name
	StartTime time.Time     // When span started
	EndTime   time.Time     // When span ended
	Duration  time.Duration // Calculated duration
	Tags      map[string]string // Key-value metadata
	mu        sync.Mutex        // Mutex for thread safety
}

// End marks the span as complete and calculates duration
func (s *Span) End() {
	s.mu.Lock()         // Acquire lock
	defer s.mu.Unlock() // Release on return

	s.EndTime = time.Now()            // Record end time
	s.Duration = s.EndTime.Sub(s.StartTime) // Calculate duration
}

// SetTag adds a key-value tag to the span
// Parameters:
//   - key: Tag name
//   - value: Tag value
func (s *Span) SetTag(key, value string) {
	s.mu.Lock()         // Acquire lock
	defer s.mu.Unlock() // Release on return

	if s.Tags == nil { // Initialize map if needed
		s.Tags = make(map[string]string)
	}
	s.Tags[key] = value // Set tag
}

// Log outputs span information using structured logging
func (s *Span) Log() {
	s.mu.Lock()         // Acquire lock
	defer s.mu.Unlock() // Release on return

	logger.Info("span completed",
		slog.String("traceID", s.TraceID),
		slog.String("spanID", s.SpanID),
		slog.String("parentID", s.ParentID),
		slog.String("name", s.Name),
		slog.Duration("duration", s.Duration),
	)
}

// =============================================================================
// TRACER FUNCTIONS
// =============================================================================

// logger is the package-level logger for trace output
var logger *slog.Logger // Global logger

func init() {
	// Initialize JSON logger for trace output
	handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level: slog.LevelDebug, // Log all levels
	})
	logger = slog.New(handler) // Create logger
}

// StartSpan creates a new span from context
// Parameters:
//   - ctx: Parent context (may contain trace/span IDs)
//   - name: Name for this span/operation
// Returns:
//   - context.Context: New context with span IDs
//   - *Span: The created span (call End() when done)
func StartSpan(ctx context.Context, name string) (context.Context, *Span) {
	// Extract or create trace ID
	traceID, ok := ctx.Value(traceIDKey).(string) // Get existing trace
	if !ok || traceID == "" {                     // Create new if missing
		traceID = NewTraceID()
	}

	// Get parent span ID if exists
	parentID, _ := ctx.Value(spanIDKey).(string) // May be empty

	// Create new span
	span := &Span{
		TraceID:   traceID,      // Set trace ID
		SpanID:    NewSpanID(),  // Generate new span ID
		ParentID:  parentID,     // Set parent (may be empty)
		Name:      name,         // Set operation name
		StartTime: time.Now(),   // Record start time
		Tags:      make(map[string]string), // Initialize tags
	}

	// Create child context with span info
	ctx = context.WithValue(ctx, traceIDKey, traceID)  // Propagate trace ID
	ctx = context.WithValue(ctx, spanIDKey, span.SpanID) // Set current span
	ctx = context.WithValue(ctx, parentIDKey, parentID)  // Set parent

	return ctx, span // Return context and span
}

// GetTraceID extracts trace ID from context
// Parameters:
//   - ctx: Context containing trace ID
// Returns:
//   - string: Trace ID or empty string
func GetTraceID(ctx context.Context) string {
	if id, ok := ctx.Value(traceIDKey).(string); ok { // Type assert
		return id // Return trace ID
	}
	return "" // Return empty if not found
}

// GetSpanID extracts current span ID from context
// Parameters:
//   - ctx: Context containing span ID
// Returns:
//   - string: Span ID or empty string
func GetSpanID(ctx context.Context) string {
	if id, ok := ctx.Value(spanIDKey).(string); ok { // Type assert
		return id // Return span ID
	}
	return "" // Return empty if not found
}

// =============================================================================
// EXAMPLE SERVICE WITH TRACING
// =============================================================================

// OrderService demonstrates tracing in a service layer
type OrderService struct{}

// CreateOrder creates an order with full tracing
// Parameters:
//   - ctx: Request context with trace info
//   - userID: User creating the order
//   - amount: Order amount
// Returns:
//   - string: Created order ID
//   - error: Error if creation fails
func (s *OrderService) CreateOrder(ctx context.Context, userID int, amount float64) (string, error) {
	// Start span for order creation
	ctx, span := StartSpan(ctx, "CreateOrder") // Create span
	defer span.End()                           // End when done
	defer span.Log()                           // Log on completion

	// Add metadata tags
	span.SetTag("userID", fmt.Sprintf("%d", userID)) // Tag with user
	span.SetTag("amount", fmt.Sprintf("%.2f", amount)) // Tag with amount

	// Simulate validation
	if err := s.validateOrder(ctx, userID, amount); err != nil { // Validate
		span.SetTag("error", err.Error()) // Tag error
		return "", err
	}

	// Simulate database insert
	orderID := s.insertOrder(ctx, userID, amount) // Insert order

	span.SetTag("orderID", orderID) // Tag result
	return orderID, nil             // Return success
}

// validateOrder validates order parameters with tracing
func (s *OrderService) validateOrder(ctx context.Context, userID int, amount float64) error {
	ctx, span := StartSpan(ctx, "ValidateOrder") // Child span
	defer span.End()                             // End when done
	defer span.Log()                             // Log on completion

	// Simulate validation
	time.Sleep(10 * time.Millisecond) // Simulate work

	if amount <= 0 { // Validation check
		return fmt.Errorf("invalid amount: %.2f", amount)
	}

	return nil // Validation passed
}

// insertOrder inserts order to database with tracing
func (s *OrderService) insertOrder(ctx context.Context, userID int, amount float64) string {
	ctx, span := StartSpan(ctx, "InsertOrder") // Child span
	defer span.End()                           // End when done
	defer span.Log()                           // Log on completion

	// Simulate database insert
	time.Sleep(50 * time.Millisecond) // Simulate DB latency

	orderID := fmt.Sprintf("ORD-%s", NewSpanID()[:8]) // Generate order ID
	span.SetTag("db_operation", "insert")             // Tag operation
	return orderID                                    // Return order ID
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================

func main() {
	fmt.Println("=== Distributed Tracing Demo ===")
	fmt.Println()

	// Create root context (simulating incoming request)
	ctx := context.Background() // Start with empty context

	// Start root span (simulating API handler)
	ctx, rootSpan := StartSpan(ctx, "HandleCreateOrderRequest")
	defer rootSpan.End()  // End when done
	defer rootSpan.Log()  // Log on completion

	rootSpan.SetTag("http.method", "POST")          // Request metadata
	rootSpan.SetTag("http.path", "/api/v1/orders")  // Request path

	// Use order service
	service := &OrderService{}                      // Create service
	orderID, err := service.CreateOrder(ctx, 123, 99.99) // Create order

	if err != nil { // Handle error
		rootSpan.SetTag("error", err.Error())
		fmt.Printf("Error: %v\n", err)
		return
	}

	rootSpan.SetTag("response.orderID", orderID) // Tag response
	fmt.Printf("\nOrder created successfully: %s\n", orderID)
	fmt.Printf("Trace ID: %s\n", GetTraceID(ctx))
}
