package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"{{.ModuleName}}/internal/job"
	"{{.ModuleName}}/internal/queue"
)

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle shutdown gracefully
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigCh
		log.Println("Shutting down...")
		cancel()
	}()

	// Create job queue
	q := queue.New(10)

	// Start workers
	numWorkers := 3
	for i := 1; i <= numWorkers; i++ {
		go worker(ctx, i, q)
	}

	// Add some sample jobs
	for i := 1; i <= 10; i++ {
		q.Enqueue(job.Job{ID: i, Payload: fmt.Sprintf("Task %d", i)})
	}

	// Wait for context cancellation
	<-ctx.Done()
	log.Println("Worker stopped")
}

func worker(ctx context.Context, id int, q *queue.Queue) {
	for {
		select {
		case <-ctx.Done():
			return
		default:
			j, ok := q.Dequeue()
			if !ok {
				continue
			}
			log.Printf("Worker %d processing: %s", id, j.Payload)
			j.Process()
		}
	}
}
