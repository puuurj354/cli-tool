package validator

// =============================================================================
// REQUEST VALIDATION
// =============================================================================
// Input validation utilities
// =============================================================================

import (
	"encoding/json" // JSON decoding
	"errors"        // Error handling
	"fmt"           // Formatting
	"net/http"      // HTTP types
	"regexp"        // Regular expressions
	"strings"       // String manipulation
)

// =============================================================================
// VALIDATION ERRORS
// =============================================================================

// ValidationError represents a field validation error
type ValidationError struct {
	Field   string `json:"field"`   // Field that failed validation
	Message string `json:"message"` // Error message
}

// ValidationErrors is a collection of validation errors
type ValidationErrors []ValidationError

// Error implements error interface
func (ve ValidationErrors) Error() string {
	if len(ve) == 0 {
		return "validation failed"
	}
	var msgs []string
	for _, e := range ve {
		msgs = append(msgs, fmt.Sprintf("%s: %s", e.Field, e.Message))
	}
	return strings.Join(msgs, "; ")
}

// HasErrors returns true if there are validation errors
func (ve ValidationErrors) HasErrors() bool {
	return len(ve) > 0
}

// =============================================================================
// VALIDATOR
// =============================================================================

// Validator validates request data
type Validator struct {
	errors ValidationErrors // Collected errors
}

// New creates a new Validator
func New() *Validator {
	return &Validator{
		errors: make(ValidationErrors, 0),
	}
}

// Required validates that a field is not empty
// Parameters:
//   - field: Field name for error message
//   - value: Value to validate
// Returns:
//   - *Validator: For method chaining
func (v *Validator) Required(field, value string) *Validator {
	if strings.TrimSpace(value) == "" {
		v.errors = append(v.errors, ValidationError{
			Field:   field,
			Message: "is required",
		})
	}
	return v
}

// MinLength validates minimum string length
func (v *Validator) MinLength(field, value string, min int) *Validator {
	if len(value) < min {
		v.errors = append(v.errors, ValidationError{
			Field:   field,
			Message: fmt.Sprintf("must be at least %d characters", min),
		})
	}
	return v
}

// MaxLength validates maximum string length
func (v *Validator) MaxLength(field, value string, max int) *Validator {
	if len(value) > max {
		v.errors = append(v.errors, ValidationError{
			Field:   field,
			Message: fmt.Sprintf("must be at most %d characters", max),
		})
	}
	return v
}

// Email validates email format
func (v *Validator) Email(field, value string) *Validator {
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if value != "" && !emailRegex.MatchString(value) {
		v.errors = append(v.errors, ValidationError{
			Field:   field,
			Message: "must be a valid email address",
		})
	}
	return v
}

// Range validates number is within range
func (v *Validator) Range(field string, value, min, max int) *Validator {
	if value < min || value > max {
		v.errors = append(v.errors, ValidationError{
			Field:   field,
			Message: fmt.Sprintf("must be between %d and %d", min, max),
		})
	}
	return v
}

// Validate returns errors if validation failed
func (v *Validator) Validate() error {
	if v.errors.HasErrors() {
		return v.errors
	}
	return nil
}

// Errors returns collected validation errors
func (v *Validator) Errors() ValidationErrors {
	return v.errors
}

// =============================================================================
// HTTP HELPERS
// =============================================================================

// DecodeAndValidate decodes JSON body and validates
// Parameters:
//   - r: HTTP request
//   - dst: Destination struct pointer
//   - validateFn: Validation function (optional)
// Returns:
//   - error: Decoding or validation error
func DecodeAndValidate(r *http.Request, dst interface{}, validateFn func() error) error {
	// Decode JSON body
	if err := json.NewDecoder(r.Body).Decode(dst); err != nil {
		return fmt.Errorf("invalid JSON: %w", err)
	}

	// Run validation function if provided
	if validateFn != nil {
		if err := validateFn(); err != nil {
			return err
		}
	}

	return nil
}

// WriteValidationError writes validation error response
// Parameters:
//   - w: HTTP response writer
//   - err: Validation error
func WriteValidationError(w http.ResponseWriter, err error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)

	var ve ValidationErrors
	if errors.As(err, &ve) {
		json.NewEncoder(w).Encode(map[string]interface{}{
			"error":   "validation failed",
			"details": ve,
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]string{
		"error": err.Error(),
	})
}
