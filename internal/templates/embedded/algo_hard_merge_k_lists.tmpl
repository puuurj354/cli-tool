package hard

import (
	"reflect"
	"testing"
)

// ListNode definition for singly-linked list.
type ListNode struct {
	Val  int
	Next *ListNode
}

// MergeKLists
// You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
// Merge all the linked-lists into one sorted linked-list and return it.
func MergeKLists(lists []*ListNode) *ListNode {
	// TODO: Implement logic (e.g. Min-Heap)
	return nil
}

// Helper to convert slice to list
func toList(nums []int) *ListNode {
	dummy := &ListNode{}
	curr := dummy
	for _, n := range nums {
		curr.Next = &ListNode{Val: n}
		curr = curr.Next
	}
	return dummy.Next
}

// Helper to convert list to slice
func toSlice(head *ListNode) []int {
	var nums []int
	for head != nil {
		nums = append(nums, head.Val)
		head = head.Next
	}
	return nums
}

func TestMergeKLists(t *testing.T) {
	l1 := toList([]int{1, 4, 5})
	l2 := toList([]int{1, 3, 4})
	l3 := toList([]int{2, 6})
	
	result := MergeKLists([]*ListNode{l1, l2, l3})
	got := toSlice(result)
	want := []int{1, 1, 2, 3, 4, 4, 5, 6}
	
	if !reflect.DeepEqual(got, want) {
		t.Errorf("MergeKLists() = %v, want %v", got, want)
	}
}
