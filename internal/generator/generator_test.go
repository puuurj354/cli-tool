package generator

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"text/template"

	"github.com/purnama/scaffold/internal/tui"
)

func TestSanitizePackageName(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"my-project", "myproject"},
		{"my_project", "myproject"},
		{"MyProject", "myproject"},
		{"my-api-server", "myapiserver"},
		{"my_api_server", "myapiserver"},
		{"myproject", "myproject"},
		{"MY-PROJECT", "myproject"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := sanitizePackageName(tt.input)
			if result != tt.expected {
				t.Errorf("sanitizePackageName(%q) = %q; want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestProcessPath(t *testing.T) {
	data := TemplateData{
		ProjectName: "my-api",
		PackageName: "myapi",
	}

	tests := []struct {
		input    string
		expected string
	}{
		{"main.go", "main.go"},
		{"{{.ProjectName}}.go", "my-api.go"},
		{"{{.ProjectName}}_test.go", "my-api_test.go"},
		{"pkg/{{.PackageName}}/main.go", "pkg/myapi/main.go"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := processPath(tt.input, data)
			if result != tt.expected {
				t.Errorf("processPath(%q) = %q; want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestProcessTemplate(t *testing.T) {
	data := TemplateData{
		ProjectName: "my-api",
		PackageName: "myapi",
		ModuleName:  "github.com/user/my-api",
		Description: "my-api - Generated by scaffold",
		License:     "MIT",
	}

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			"simple project name",
			"package main\n// {{.ProjectName}}",
			"package main\n// my-api",
		},
		{
			"module name",
			`import "{{.ModuleName}}/internal"`,
			`import "github.com/user/my-api/internal"`,
		},
		{
			"package name",
			`package {{.PackageName}}`,
			`package myapi`,
		},
		{
			"description",
			`// {{.Description}}`,
			`// my-api - Generated by scaffold`,
		},
		{
			"multiple variables",
			`package {{.PackageName}}
import "{{.ModuleName}}"
// {{.ProjectName}}`,
			`package myapi
import "github.com/user/my-api"
// my-api`,
		},
		{
			"no variables",
			"package main\nfunc main() {}",
			"package main\nfunc main() {}",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := processTemplate(tt.input, data)
			if err != nil {
				t.Fatalf("processTemplate failed: %v", err)
			}
			if result != tt.expected {
				t.Errorf("processTemplate = %q; want %q", result, tt.expected)
			}
		})
	}
}

func TestProcessTemplateError(t *testing.T) {
	data := TemplateData{
		ProjectName: "my-api",
	}

	// Invalid template syntax
	invalidTemplate := "{{.NonExistent}}"
	_, err := processTemplate(invalidTemplate, data)
	if err != nil {
		t.Logf("Expected error for invalid template: %v", err)
	}
}

func TestGenerateDirStructure(t *testing.T) {
	// Create temporary directory for test
	tmpDir := t.TempDir()
	originalCwd, _ := os.Getwd()
	defer os.Chdir(originalCwd)
	os.Chdir(tmpDir)

	config := tui.ProjectConfig{
		ProjectName:   "test-project",
		TemplateName:  "go-api",
		License:       "MIT",
		IncludeDocker: false,
		InitGit:       false,
	}

	opts := Options{
		DryRun: false,
		Force:  false,
	}

	err := GenerateWithOptions(config, opts)
	if err != nil {
		t.Fatalf("GenerateWithOptions failed: %v", err)
	}

	// Verify project directory was created
	projectPath := filepath.Join(tmpDir, "test-project")
	if _, err := os.Stat(projectPath); os.IsNotExist(err) {
		t.Errorf("project directory not created: %s", projectPath)
	}

	// Verify go.mod exists
	goModPath := filepath.Join(projectPath, "go.mod")
	if _, err := os.Stat(goModPath); os.IsNotExist(err) {
		t.Errorf("go.mod not created: %s", goModPath)
	}

	// Verify main files exist
	mainPath := filepath.Join(projectPath, "cmd/api/main.go")
	if _, err := os.Stat(mainPath); os.IsNotExist(err) {
		t.Errorf("main.go not created: %s", mainPath)
	}
}

func TestGenerateDryRun(t *testing.T) {
	tmpDir := t.TempDir()
	originalCwd, _ := os.Getwd()
	defer os.Chdir(originalCwd)
	os.Chdir(tmpDir)

	config := tui.ProjectConfig{
		ProjectName:   "test-project",
		TemplateName:  "go-cli",
		License:       "MIT",
		IncludeDocker: false,
		InitGit:       false,
	}

	opts := Options{
		DryRun: true,
		Force:  false,
	}

	err := GenerateWithOptions(config, opts)
	if err != nil {
		t.Fatalf("GenerateWithOptions (dry-run) failed: %v", err)
	}

	// Verify project directory was NOT created
	projectPath := filepath.Join(tmpDir, "test-project")
	if _, err := os.Stat(projectPath); err == nil {
		t.Errorf("project directory should not exist in dry-run mode")
	}
}

func TestGenerateForceOverwrite(t *testing.T) {
	tmpDir := t.TempDir()
	originalCwd, _ := os.Getwd()
	defer os.Chdir(originalCwd)
	os.Chdir(tmpDir)

	projectPath := filepath.Join(tmpDir, "test-project")
	os.Mkdir(projectPath, 0755)

	// First without force should fail
	config := tui.ProjectConfig{
		ProjectName:   "test-project",
		TemplateName:  "go-cli",
		License:       "MIT",
		IncludeDocker: false,
		InitGit:       false,
	}

	opts := Options{Force: false}
	err := GenerateWithOptions(config, opts)
	if err == nil {
		t.Error("expected error when directory exists and Force is false")
	}

	// Second with force should succeed
	opts.Force = true
	err = GenerateWithOptions(config, opts)
	if err != nil {
		t.Fatalf("GenerateWithOptions with Force=true failed: %v", err)
	}
}

func TestGenerateFilePermissions(t *testing.T) {
	tmpDir := t.TempDir()
	originalCwd, _ := os.Getwd()
	defer os.Chdir(originalCwd)
	os.Chdir(tmpDir)

	config := tui.ProjectConfig{
		ProjectName:   "test-project",
		TemplateName:  "go-cli",
		License:       "MIT",
		IncludeDocker: false,
		InitGit:       false,
	}

	opts := Options{DryRun: false, Force: false}
	err := GenerateWithOptions(config, opts)
	if err != nil {
		t.Fatalf("GenerateWithOptions failed: %v", err)
	}

	projectPath := filepath.Join(tmpDir, "test-project")

	// Check directory permissions (should be 0755)
	dirInfo, _ := os.Stat(projectPath)
	dirMode := dirInfo.Mode().Perm()
	expectedDirMode := os.FileMode(0755)
	if dirMode != expectedDirMode {
		t.Logf("directory mode: %o, expected: %o", dirMode, expectedDirMode)
	}

	// Check file permissions (should be 0644)
	filePath := filepath.Join(projectPath, "main.go")
	if fileInfo, err := os.Stat(filePath); err == nil {
		fileMode := fileInfo.Mode().Perm()
		expectedFileMode := os.FileMode(0644)
		if fileMode != expectedFileMode {
			t.Logf("file mode: %o, expected: %o", fileMode, expectedFileMode)
		}
	}
}

func TestGenerateLicense(t *testing.T) {
	data := TemplateData{
		ProjectName: "test-project",
	}

	tests := []struct {
		name            string
		licenseType     string
		expectedContent []string
	}{
		{
			"MIT license",
			"MIT",
			[]string{"MIT License", "test-project", "Permission is hereby granted"},
		},
		{
			"Apache 2.0 license",
			"Apache 2.0",
			[]string{"Apache License", "Version 2.0", "test-project"},
		},
		{
			"GPL 3.0 license",
			"GPL 3.0",
			[]string{"GNU General Public License", "test-project"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			license := generateLicense(tt.licenseType, data.ProjectName)

			if license == "" {
				t.Errorf("generateLicense(%q) returned empty string", tt.licenseType)
			}

			for _, expected := range tt.expectedContent {
				if !strings.Contains(license, expected) {
					t.Errorf("license missing expected content: %q", expected)
				}
			}
		})
	}
}

func TestGenerateDockerfile(t *testing.T) {
	data := TemplateData{
		ProjectName: "my-api",
	}

	tests := []struct {
		name             string
		templateName     string
		expectedContent  []string
		shouldNotContain []string
	}{
		{
			"go-api dockerfile",
			"go-api",
			[]string{"golang:1.21-alpine", "WORKDIR /app", "./api"},
			[]string{},
		},
		{
			"go-cli dockerfile",
			"go-cli",
			[]string{"golang:1.21-alpine", "WORKDIR /app", "my-api"},
			[]string{},
		},
		{
			"default dockerfile",
			"go-tui",
			[]string{"golang:1.21-alpine", "WORKDIR /app"},
			[]string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dockerfile := generateDockerfile(tt.templateName, data)

			if dockerfile == "" {
				t.Errorf("generateDockerfile(%q) returned empty string", tt.templateName)
			}

			for _, expected := range tt.expectedContent {
				if !strings.Contains(dockerfile, expected) {
					t.Errorf("dockerfile missing expected content: %q", expected)
				}
			}

			for _, notExpected := range tt.shouldNotContain {
				if strings.Contains(dockerfile, notExpected) {
					t.Errorf("dockerfile should not contain: %q", notExpected)
				}
			}
		})
	}
}

func TestTemplateDataVariables(t *testing.T) {
	data := TemplateData{
		ProjectName: "my-api",
		PackageName: "myapi",
		ModuleName:  "github.com/user/my-api",
		Description: "my-api - API server",
		License:     "MIT",
	}

	// Create a simple template to test
	tmpl, err := template.New("test").Parse(`
Project: {{.ProjectName}}
Package: {{.PackageName}}
Module: {{.ModuleName}}
Description: {{.Description}}
License: {{.License}}
`)
	if err != nil {
		t.Fatalf("template parse failed: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		t.Fatalf("template execute failed: %v", err)
	}

	result := buf.String()

	expectedPairs := map[string]string{
		"Project:": "my-api",
		"Package:": "myapi",
		"Module:":  "github.com/user/my-api",
		"License:": "MIT",
	}

	for key, value := range expectedPairs {
		if !strings.Contains(result, key) || !strings.Contains(result, value) {
			t.Errorf("template result missing %s %s", key, value)
		}
	}
}
