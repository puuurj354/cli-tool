package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/purnama/scaffold/internal/templates"
	"github.com/purnama/scaffold/internal/tui"
)

// Options holds generator options
type Options struct {
	DryRun bool
	Force  bool
}

// Generate creates the project structure (backward compatibility)
func Generate(config tui.ProjectConfig) error {
	return GenerateWithOptions(config, Options{})
}

// GenerateWithOptions creates the project structure with options
func GenerateWithOptions(config tui.ProjectConfig, opts Options) error {
	if opts.DryRun {
		return previewProject(config)
	}

	fmt.Printf("\nüöÄ Creating project: %s\n", config.ProjectName)

	// Get the template
	tmpl, err := templates.GetTemplate(config.TemplateName)
	if err != nil {
		return err
	}

	// Get current directory
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}

	// Create project directory
	projectDir := filepath.Join(cwd, config.ProjectName)

	// Check if directory exists
	if _, err := os.Stat(projectDir); err == nil {
		if !opts.Force {
			return fmt.Errorf("directory '%s' already exists. Use --force to overwrite", config.ProjectName)
		}
		fmt.Println("‚ö†Ô∏è  Directory exists, overwriting...")
	}

	if err := os.MkdirAll(projectDir, 0755); err != nil {
		return fmt.Errorf("failed to create project directory: %w", err)
	}
	fmt.Printf("üìÅ Created project directory: %s/\n", config.ProjectName)

	// Template data for file content substitution
	data := TemplateData{
		ProjectName: config.ProjectName,
		PackageName: sanitizePackageName(config.ProjectName),
		ModuleName:  fmt.Sprintf("github.com/user/%s", config.ProjectName),
		Description: fmt.Sprintf("%s - Generated by scaffold", config.ProjectName),
		License:     config.License,
	}

	// Create directories inside project directory
	fmt.Println("üìÅ Creating directories...")
	for _, dir := range tmpl.Directories {
		dirPath := filepath.Join(projectDir, dir)
		if err := os.MkdirAll(dirPath, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
		fmt.Printf("   ‚úì %s/\n", dir)
	}

	// Create files inside project directory
	fmt.Println("üìÑ Creating files...")
	for _, f := range tmpl.Files {
		filePath := processPath(f.Path, data)
		fullPath := filepath.Join(projectDir, filePath)

		// Ensure parent directory exists
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			return fmt.Errorf("failed to create parent dir for %s: %w", filePath, err)
		}

		// Process template content
		content, err := processTemplate(f.Content, data)
		if err != nil {
			return fmt.Errorf("failed to process template for %s: %w", filePath, err)
		}

		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to write file %s: %w", filePath, err)
		}
		fmt.Printf("   ‚úì %s\n", filePath)
	}

	// Initialize go.mod inside project directory (skip for fullstack frontend)
	if config.TemplateName != "fullstack" {
		fmt.Println("üì¶ Initializing Go module...")
		cmd := exec.Command("go", "mod", "init", data.ModuleName)
		cmd.Dir = projectDir
		if output, err := cmd.CombinedOutput(); err != nil {
			fmt.Printf("   ‚ö† go mod init: %s\n", string(output))
		} else {
			fmt.Printf("   ‚úì go.mod\n")
		}
	}

	// Add Dockerfile if requested
	if config.IncludeDocker {
		fmt.Println("üê≥ Adding Dockerfile...")
		dockerContent := generateDockerfile(config.TemplateName, data)
		dockerPath := filepath.Join(projectDir, "Dockerfile")
		if err := os.WriteFile(dockerPath, []byte(dockerContent), 0644); err != nil {
			return fmt.Errorf("failed to write Dockerfile: %w", err)
		}
		fmt.Printf("   ‚úì Dockerfile\n")
	}

	// Add license if specified
	if config.License != "None" && config.License != "" {
		fmt.Println("üìú Adding license...")
		licenseContent := generateLicense(config.License, data.ProjectName)
		licensePath := filepath.Join(projectDir, "LICENSE")
		if err := os.WriteFile(licensePath, []byte(licenseContent), 0644); err != nil {
			return fmt.Errorf("failed to write LICENSE: %w", err)
		}
		fmt.Printf("   ‚úì LICENSE (%s)\n", config.License)
	}

	// Initialize git if requested
	if config.InitGit {
		fmt.Println("üîß Initializing git repository...")
		cmd := exec.Command("git", "init")
		cmd.Dir = projectDir
		if output, err := cmd.CombinedOutput(); err != nil {
			fmt.Printf("   ‚ö† git init: %s\n", string(output))
		} else {
			fmt.Printf("   ‚úì .git/\n")
		}
	}

	// Run post-init hooks
	runPostInitHooks(projectDir, config.TemplateName)

	fmt.Printf("\n‚úÖ Project '%s' created successfully!\n", config.ProjectName)
	printNextSteps(config)

	return nil
}

// previewProject shows what would be created without actually creating
func previewProject(config tui.ProjectConfig) error {
	tmpl, err := templates.GetTemplate(config.TemplateName)
	if err != nil {
		return err
	}

	fmt.Println("\nüîç DRY RUN - Preview of what will be created:")
	fmt.Printf("\nüì¶ Project: %s/\n", config.ProjectName)

	for _, dir := range tmpl.Directories {
		fmt.Printf("   üìÅ %s/\n", dir)
	}
	for _, f := range tmpl.Files {
		fmt.Printf("   üìÑ %s\n", f.Path)
	}

	fmt.Println("\n   üìÑ go.mod")
	if config.IncludeDocker {
		fmt.Println("   üê≥ Dockerfile")
	}
	if config.License != "None" && config.License != "" {
		fmt.Printf("   üìú LICENSE (%s)\n", config.License)
	}
	if config.InitGit {
		fmt.Println("   üîß .git/")
	}

	fmt.Println("\nüí° Remove --dry-run to create the project")
	return nil
}

// runPostInitHooks runs template-specific post-initialization commands
func runPostInitHooks(projectDir, templateName string) {
	switch templateName {
	case "fullstack":
		// Check if bun is available
		if _, err := exec.LookPath("bun"); err == nil {
			fmt.Println("üì¶ Running post-init hooks...")
			frontendDir := filepath.Join(projectDir, "frontend")
			cmd := exec.Command("bun", "install")
			cmd.Dir = frontendDir
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			if err := cmd.Run(); err != nil {
				fmt.Printf("   ‚ö† bun install failed: %v\n", err)
			} else {
				fmt.Println("   ‚úì Frontend dependencies installed")
			}
		}
	}
}

func printNextSteps(config tui.ProjectConfig) {
	fmt.Println("\nNext steps:")
	fmt.Printf("   cd %s\n", config.ProjectName)

	switch config.TemplateName {
	case "fullstack":
		fmt.Println("   make dev    # Runs backend + frontend")
	case "go-api":
		fmt.Println("   go mod tidy")
		fmt.Println("   go run ./cmd/api")
	case "go-cli":
		fmt.Println("   go mod tidy")
		fmt.Println("   go run .")
	case "go-grpc":
		fmt.Println("   go mod tidy")
		fmt.Println("   make run-server")
	case "go-worker":
		fmt.Println("   go mod tidy")
		fmt.Println("   go run ./cmd/worker")
	case "go-tui":
		fmt.Println("   go mod tidy")
		fmt.Println("   go run .")
	case "learn-concurrency":
		fmt.Println("   cd 01-goroutines && go run main.go")
	case "learn-testing":
		fmt.Println("   go test -v ./...")
	case "learn-dsa":
		fmt.Println("   go test -v ./...   # See which tests fail")
		fmt.Println("   # Then implement the functions!")
	case "challenge-30days":
		fmt.Println("   cd week1/day01_hello")
		fmt.Println("   go test -v          # See failing tests")
		fmt.Println("   # Implement the functions, then move to next day!")
	case "mini-project":
		fmt.Println("   cd todo-cli         # or url-shortener")
		fmt.Println("   go test -v          # See what to implement")
		fmt.Println("   # Read README.md for requirements")
	case "refactoring-exercise":
		fmt.Println("   cd exercises/01_long_function")
		fmt.Println("   # Look at before.go, read hints.md")
		fmt.Println("   # Create after.go with your refactored code")
	case "code-review-exercise":
		fmt.Println("   cd bugs/01_off_by_one")
		fmt.Println("   go test -v          # See the failing tests")
		fmt.Println("   # Find and fix the bugs in buggy.go!")
	default:
		fmt.Println("   go mod tidy")
		fmt.Println("   go test ./...")
	}
}

// TemplateData holds data for template substitution
type TemplateData struct {
	ProjectName string
	PackageName string
	ModuleName  string
	Description string
	License     string
}

func sanitizePackageName(name string) string {
	// Replace hyphens and underscores with nothing for package names
	name = strings.ReplaceAll(name, "-", "")
	name = strings.ReplaceAll(name, "_", "")
	return strings.ToLower(name)
}

func processPath(path string, data TemplateData) string {
	path = strings.ReplaceAll(path, "{{.ProjectName}}", data.ProjectName)
	path = strings.ReplaceAll(path, "{{.PackageName}}", data.PackageName)
	return path
}

func processTemplate(content string, data TemplateData) (string, error) {
	tmpl, err := template.New("file").Parse(content)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func generateDockerfile(templateName string, data TemplateData) string {
	switch templateName {
	case "go-api":
		return fmt.Sprintf(`FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/bin/api ./cmd/api

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /app
COPY --from=builder /app/bin/api .
EXPOSE 8080
CMD ["./api"]
`)
	case "go-cli":
		return fmt.Sprintf(`FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o /app/bin/%s .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /app
COPY --from=builder /app/bin/%s .
ENTRYPOINT ["./%s"]
`, data.ProjectName, data.ProjectName, data.ProjectName)
	default:
		return `FROM golang:1.21-alpine
WORKDIR /app
COPY . .
RUN go build -o /app/bin/app .
CMD ["./bin/app"]
`
	}
}

func generateLicense(licenseType, projectName string) string {
	year := "2026"

	switch licenseType {
	case "MIT":
		return fmt.Sprintf(`MIT License

Copyright (c) %s %s

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
`, year, projectName)
	case "Apache 2.0":
		return fmt.Sprintf(`Copyright %s %s

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
`, year, projectName)
	case "GPL 3.0":
		return fmt.Sprintf(`%s - Copyright (c) %s

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
`, projectName, year)
	default:
		return ""
	}
}
